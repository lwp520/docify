# 泛型
## 类型擦除一
Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉。
<font color="red">Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</font><br/>
如在代码中定义List和List等类型，在编译后都会变成List，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。<br/>
<font color="red">泛型不能用于显性地引用运行时类型的操作之中，例如转型，instanceof和new操作（包括new一个对象，new一个数组），因为所有关于参数的类型信息都在运行时丢失了，所以任何在运行时需要获取类型信息的操作都无法进行工作。</font>

## 类型擦除二
<div>
我们首先单独编译项目：`Build -> Build Project`
然后点击查看`GenericList`的字节码：`View -> Show Bytecode`
类型擦除即，当我们泛型参数时，`JVM`会对具体的类型进行擦除，取决于以下几个情况：

- 单一的泛型参数：类型替换成`Object`
- 单一的类型约束：类型替换成约束类型
- 有多个类型约束：替换成最左边的约束类型

泛型参数只是在编译期间用于对类型进行检测。
</div>

![泛型](../images/type.png)

## 泛型约束
1、<font color="red">无边界的通配符</font>（Unbounded Wildcards）<br/>
采用 <?> 的形式，比如 List<?>，无边界的通配符的主要作用就是让泛型能够接受未知类型的数据。<br/>

2、<font color="red">固定上边界的通配符</font>（Upper BoundedWildcards）<br/>

使用固定上边界的通配符的泛型，就能够接受指定类及其子类类型的数据。要声明使用该类通配符，采用 <font color="red"><? extends E></font> 的形式，这里的 E 就是该泛型的上边界。<br/>

注意：这里虽然用的是 extends 关键字，却不仅限于继承了父类 E 的子类，也可以代指实现了接口 E 的类。<br/>
3、<font color="red">固定下边界的通配符</font>（Lower Bounded Wildcards）<br/>

使用固定下边界的通配符的泛型，就能够接受指定类及其父类类型的数据。要声明使用该类通配符，采用 <? super E> 的形式，这里的 E 就是该泛型的下边界。<br/>

注意：你可以为一个泛型指定上边界或下边界，但是不能同时指定上下边界。<br/>


